{"categories":[{"title":"r code","uri":"https://jmbarbone.github.io/categories/r-code/"}],"posts":[{"content":"\r\rI can spend a lot of time trying in futility to optimize custom functions and code.\rI’ll take the time to rewrite the same thing in two or more ways and run some basic benchmarks for performance differences.\rMost of the time I’m just exploring the simplest possible way to perform an action and what would be the most generalizable solution that could extend to other problems.\rI ran into an issue where I had to use a quick function to find the total amount of time a subject in a clinical trial was on a specific dose.\rHowever, subjects had doses adjusted through the study for optimization.\rFurther, we also needed to count the dosing based on the lowest dose provided.\n\rFor example, how long was Subject A on a \u0026gt;= 10mg dose?\n\rSo, let’s explore three different ways to solve this problem and why all three are valid and just as efficient.\nSet up\rLoading our tidyverse packages first.\rBecause we will be grouping and summarising data in a data.frame, I really don’t feel like going through the trouble of using base solutions.\noptions(tidyverse.quiet = TRUE) # Silences messages\rlibrary(tidyverse)\rLet’s create some random data to represent our subjects, our doses, and an arbitrary time metric.\rWe’re also going to make this harder by using the difftime.\nWe’re also going to grab some names using a function from the wakefield package which you can use to create fake data, appropriately named. [^note]\n^note: I’m not too savvy with this package yet but would like to experiment more for building dummy data sets.\nsubj \u0026lt;- sort(sample(wakefield::name(500), 1e4, TRUE))\rdose \u0026lt;- sample(seq.int(10, 80, 10), 1e4, TRUE)\rtime \u0026lt;- as.difftime(runif(1e4) * 100, units = \u0026quot;days\u0026quot;)\rdf \u0026lt;- tibble(subj, dose, time)\rdf\r# A tibble: 10,000 x 3\rsubj dose time \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;drtn\u0026gt; 1 Aadhya 10 81.430584 days\r2 Aadhya 10 80.324186 days\r3 Aadhya 40 64.917350 days\r4 Aadhya 80 17.631323 days\r5 Aadhya 40 8.970711 days\r6 Aadhya 20 96.518079 days\r7 Aadhya 60 61.493537 days\r8 Aadhya 20 29.073014 days\r9 Aadhya 80 6.221622 days\r10 Aaditri 50 54.387006 days\r# ... with 9,990 more rows\rFinding the total sum of time at each dose is easy:\ndf %\u0026gt;% group_by(subj, dose) %\u0026gt;% summarise(time = sum(time), .groups = \u0026quot;drop\u0026quot;) %\u0026gt;% pivot_wider(names_from = \u0026quot;dose\u0026quot;,\rnames_sort = TRUE,\rvalues_from = \u0026quot;time\u0026quot;)\r# A tibble: 500 x 9\rsubj `10` `20` `30` `40` `50` `60` `70` `80` \u0026lt;chr\u0026gt; \u0026lt;drtn\u0026gt; \u0026lt;drtn\u0026gt; \u0026lt;drtn\u0026gt; \u0026lt;drtn\u0026gt; \u0026lt;drtn\u0026gt; \u0026lt;drtn\u0026gt; \u0026lt;drtn\u0026gt; \u0026lt;drtn\u0026gt; 1 Aadhya 161.7547~ 125.591~ ~ 73.8880~ ~ 61.49~ ~ 23.85~\r2 Aadit~ 30.6712~ 172.203~ ~ 224.9110~ 131.421~ 193.56~ 67.98~ 93.22~\r3 Aalee~ 174.6785~ 115.274~ 159.963~ 198.0695~ 184.672~ 77.62~ 214.77~ 292.39~\r4 Aaley~ 183.8605~ 88.263~ ~ 9.1255~ 261.859~ 259.78~ 214.15~ 100.03~\r5 Aamia 70.4298~ 149.781~ 122.847~ 40.4504~ 32.994~ 74.87~ 116.54~ 161.57~\r6 Aarish 232.1889~ 234.424~ 70.517~ ~ 7.558~ 111.19~ 153.24~ 118.05~\r7 Abdul~ 8.8906~ 37.666~ 130.246~ ~ ~ 215.40~ 159.77~ 162.15~\r8 Abhin~ 221.3729~ 108.876~ 114.363~ 280.9107~ 136.460~ 100.08~ 97.43~ 95.31~\r9 Abhir~ 73.2359~ 182.813~ 295.836~ 107.8884~ 96.700~ 137.15~ 123.40~ 68.99~\r10 Abyade 107.6382~ 596.182~ 168.711~ 146.6280~ 61.121~ 34.35~ 281.28~ 149.84~\r# ... with 490 more rows\rOh, it looks like we have some missing values (see the first line where we are missing doses of 30, 50, and 70 for Aadhya.).\rtidyr::pivot_wider() allows us to fill in the missing values but like many tidyverse functions, we’ll have to be explicit with the type so as to not case any accidental issues.\ndifftime0 \u0026lt;- as.difftime(0, units = \u0026quot;days\u0026quot;)\rres \u0026lt;- df %\u0026gt;% group_by(subj, dose) %\u0026gt;% summarise(time = sum(time), .groups = \u0026quot;drop\u0026quot;) %\u0026gt;% pivot_wider(names_from = \u0026quot;dose\u0026quot;,\rnames_sort = TRUE,\rvalues_from = \u0026quot;time\u0026quot;,\rvalues_fill = difftime0)\rres\r# A tibble: 500 x 9\rsubj `10` `20` `30` `40` `50` `60` `70` `80` \u0026lt;chr\u0026gt; \u0026lt;drtn\u0026gt; \u0026lt;drtn\u0026gt; \u0026lt;drtn\u0026gt; \u0026lt;drtn\u0026gt; \u0026lt;drtn\u0026gt; \u0026lt;drtn\u0026gt; \u0026lt;drtn\u0026gt; \u0026lt;drtn\u0026gt; 1 Aadhya 161.7547~ 125.591~ 0.000~ 73.8880~ 0.000~ 61.49~ 0.00~ 23.85~\r2 Aadit~ 30.6712~ 172.203~ 0.000~ 224.9110~ 131.421~ 193.56~ 67.98~ 93.22~\r3 Aalee~ 174.6785~ 115.274~ 159.963~ 198.0695~ 184.672~ 77.62~ 214.77~ 292.39~\r4 Aaley~ 183.8605~ 88.263~ 0.000~ 9.1255~ 261.859~ 259.78~ 214.15~ 100.03~\r5 Aamia 70.4298~ 149.781~ 122.847~ 40.4504~ 32.994~ 74.87~ 116.54~ 161.57~\r6 Aarish 232.1889~ 234.424~ 70.517~ 0.0000~ 7.558~ 111.19~ 153.24~ 118.05~\r7 Abdul~ 8.8906~ 37.666~ 130.246~ 0.0000~ 0.000~ 215.40~ 159.77~ 162.15~\r8 Abhin~ 221.3729~ 108.876~ 114.363~ 280.9107~ 136.460~ 100.08~ 97.43~ 95.31~\r9 Abhir~ 73.2359~ 182.813~ 295.836~ 107.8884~ 96.700~ 137.15~ 123.40~ 68.99~\r10 Abyade 107.6382~ 596.182~ 168.711~ 146.6280~ 61.121~ 34.35~ 281.28~ 149.84~\r# ... with 490 more rows\rThis is much more troublesome as we have to create single length difftime vector.\nNow, we need to find the total length of time a subject was at each dose or greater..\rThis I wasn’t able to do with any built in functions (although I could have missed it).\rI’m not claiming this is the best function or anything, it’s not, but I have 3 different solutions and thought it was enough to spend my evening writing a blog post.\nSolution 1: The For Loop\rNever use a for loop, except if you have to.\rWe’ll start with\nfoo1 \u0026lt;- function(x, y) {\rout \u0026lt;- y\rfor (i in seq_along(y)) {\rout[i] \u0026lt;- sum(y[x \u0026gt;= x[i]])\r}\rout\r}\r\rSolution 2: Combining lapply\rWhen having to play with dates before, I found that the way I could retain the date values and still use a function from the apply family was to stick with the lapply() and then use the do.call() function to apply the combine function over my list.\rlapply() retains the original classes and using the do.call(c, ...) method will turn my list into a vector without removing the structure of the output\nfoo2 \u0026lt;- function(x, y) {\rout \u0026lt;- lapply(x, function(xx) sum(y[x \u0026gt;= xx]))\rdo.call(c, out)\r}\rLet’s see how this plays out.\rIf we use other methods, we lose the difftime class, which is noticeable as we don’t get our message of Time differences in days before our results.\nx \u0026lt;- lapply(dose, function(xx) sum(time[dose \u0026gt;= xx])) %\u0026gt;% unlist() %\u0026gt;% head()\rx; class(x); typeof(x)\r[1] 501497.92 501497.92 312102.52 61765.11 312102.52 437797.16\r[1] \u0026quot;numeric\u0026quot;\r[1] \u0026quot;double\u0026quot;\rx \u0026lt;- sapply(dose, function(xx) sum(time[dose \u0026gt;= xx])) %\u0026gt;% head()\rx; class(x); typeof(x)\r[1] 501497.92 501497.92 312102.52 61765.11 312102.52 437797.16\r[1] \u0026quot;numeric\u0026quot;\r[1] \u0026quot;double\u0026quot;\rx \u0026lt;- foo2(dose, time) %\u0026gt;% head()\rx; class(x); typeof(x)\rTime differences in days\r[1] 501497.92 501497.92 312102.52 61765.11 312102.52 437797.16\r[1] \u0026quot;difftime\u0026quot;\r[1] \u0026quot;double\u0026quot;\r\rSolution 3: Vapply with subset assigning\rHere’s another neat little trick that with a good use case.\rWe’re going to subset our out object (again, a copy of the y intput) and assign over it the result of our vapply.\rWe’re also going to cheat and use the first position of y as our FUN.VALUE.\nfoo3 \u0026lt;- function(x, y) {\rout \u0026lt;- y\rout[] \u0026lt;- vapply(x, function(xx) sum(y[x \u0026gt;= xx]), time[1], USE.NAMES = FALSE)\rout\r}\rLet’s take look just like before.\rvapply() will try to simplify the FUN.VALUE but as long as we use a single vector from the original input we can safely assign it back into our mock subset without worrying about losing our classes.\nx \u0026lt;- vapply(dose, function(xx) sum(time[dose \u0026gt;= xx]), time[1]) %\u0026gt;% head()\rx; class(x); typeof(x)\r[1] 501497.92 501497.92 312102.52 61765.11 312102.52 437797.16\r[1] \u0026quot;numeric\u0026quot;\r[1] \u0026quot;double\u0026quot;\rx \u0026lt; -foo3(dose, time) %\u0026gt;% head()\r[1] FALSE FALSE FALSE FALSE FALSE FALSE\rx; class(x); typeof(x)\r[1] 501497.92 501497.92 312102.52 61765.11 312102.52 437797.16\r[1] \u0026quot;numeric\u0026quot;\r[1] \u0026quot;double\u0026quot;\r\r\rBenchmarks\rNow, all three of these solutions produce the same results and are fairly equivalent in human legibility.\rThis means, for me at least, that the function which runs the fastest would be the result I keep.\rWe’ll employ the microbenchmark package and eponymous name for our consideration.\nOf course, for this we’ll be running on the vectors first.\rWe’ll also make certain that all of our outputs are the same with check = \"equal\" to make sure we didn’t miss anything either.\nmicrobenchmark::microbenchmark(\rfoo1(dose, time),\rfoo2(dose, time),\rfoo3(dose, time),\rtimes = 20,\rcheck = \u0026quot;equal\u0026quot;\r)\rUnit: seconds\rexpr min lq mean median uq max neval\rfoo1(dose, time) 1.983364 2.085853 2.257241 2.166570 2.253940 4.024464 20\rfoo2(dose, time) 2.011665 2.095127 2.242120 2.148517 2.246046 3.469991 20\rfoo3(dose, time) 1.994900 2.068829 2.272299 2.153669 2.414414 2.972942 20\rcld\ra\ra\ra\rAnd, well, they all run about the same.\rThat kind of just leaves us with the sinking feeling that all of this was futile and that for loops really aren’t that bad.\rIn fact, the for loop solution may be the easiest to read and doesn’t use any tricks that someone reviewing your code may not understand at first.\nWe know we have some missing values in our data, so we’re going to use the the tidyr::complete() function to help with that.\nres\r# A tibble: 500 x 9\rsubj `10` `20` `30` `40` `50` `60` `70` `80` \u0026lt;chr\u0026gt; \u0026lt;drtn\u0026gt; \u0026lt;drtn\u0026gt; \u0026lt;drtn\u0026gt; \u0026lt;drtn\u0026gt; \u0026lt;drtn\u0026gt; \u0026lt;drtn\u0026gt; \u0026lt;drtn\u0026gt; \u0026lt;drtn\u0026gt; 1 Aadhya 161.7547~ 125.591~ 0.000~ 73.8880~ 0.000~ 61.49~ 0.00~ 23.85~\r2 Aadit~ 30.6712~ 172.203~ 0.000~ 224.9110~ 131.421~ 193.56~ 67.98~ 93.22~\r3 Aalee~ 174.6785~ 115.274~ 159.963~ 198.0695~ 184.672~ 77.62~ 214.77~ 292.39~\r4 Aaley~ 183.8605~ 88.263~ 0.000~ 9.1255~ 261.859~ 259.78~ 214.15~ 100.03~\r5 Aamia 70.4298~ 149.781~ 122.847~ 40.4504~ 32.994~ 74.87~ 116.54~ 161.57~\r6 Aarish 232.1889~ 234.424~ 70.517~ 0.0000~ 7.558~ 111.19~ 153.24~ 118.05~\r7 Abdul~ 8.8906~ 37.666~ 130.246~ 0.0000~ 0.000~ 215.40~ 159.77~ 162.15~\r8 Abhin~ 221.3729~ 108.876~ 114.363~ 280.9107~ 136.460~ 100.08~ 97.43~ 95.31~\r9 Abhir~ 73.2359~ 182.813~ 295.836~ 107.8884~ 96.700~ 137.15~ 123.40~ 68.99~\r10 Abyade 107.6382~ 596.182~ 168.711~ 146.6280~ 61.121~ 34.35~ 281.28~ 149.84~\r# ... with 490 more rows\rdf %\u0026gt;% complete(subj, dose, fill = list(time = difftime0)) %\u0026gt;% group_by(subj, dose) %\u0026gt;% summarise(time = sum(time), .groups = \u0026quot;drop_last\u0026quot;) %\u0026gt;%\rmutate(time = foo1(dose, time)) %\u0026gt;% pivot_wider(names_from = \u0026quot;dose\u0026quot;,\rnames_sort = TRUE,\rvalues_from = \u0026quot;time\u0026quot;)\r# A tibble: 500 x 9\r# Groups: subj [500]\rsubj `10` `20` `30` `40` `50` `60` `70` `80` \u0026lt;chr\u0026gt; \u0026lt;drtn\u0026gt; \u0026lt;drtn\u0026gt; \u0026lt;drtn\u0026gt; \u0026lt;drtn\u0026gt; \u0026lt;drtn\u0026gt; \u0026lt;drtn\u0026gt; \u0026lt;drtn\u0026gt; \u0026lt;drtn\u0026gt; 1 Aadhya 446.58~ 284.82~ 159.23~ 159.234~ 85.346~ 85.346~ 23.852~ 23.85~\r2 Aadit~ 913.98~ 883.31~ 711.10~ 711.108~ 486.197~ 354.775~ 161.214~ 93.22~\r3 Aalee~ 1417.45~ 1242.77~ 1127.50~ 967.539~ 769.470~ 584.797~ 507.168~ 292.39~\r4 Aaley~ 1117.08~ 933.22~ 844.96~ 844.960~ 835.834~ 573.975~ 314.189~ 100.03~\r5 Aamia 769.48~ 699.05~ 549.27~ 426.427~ 385.976~ 352.982~ 278.111~ 161.57~\r6 Aarish 927.18~ 694.99~ 460.56~ 390.051~ 390.051~ 382.493~ 271.300~ 118.05~\r7 Abdul~ 714.13~ 705.24~ 667.57~ 537.329~ 537.328~ 537.328~ 321.928~ 162.15~\r8 Abhin~ 1154.81~ 933.44~ 824.57~ 710.207~ 429.296~ 292.835~ 192.746~ 95.31~\r9 Abhir~ 1086.02~ 1012.79~ 829.97~ 534.142~ 426.253~ 329.553~ 192.403~ 68.99~\r10 Abyade 1545.76~ 1438.12~ 841.94~ 673.233~ 526.605~ 465.484~ 431.129~ 149.84~\r# ... with 490 more rows\rAnd there you go.\rThree solutions, all the same.\nSometimes it’s useful to try to optimize code.\rOther times it’s just results in a blog post.\nAs long as your code is easy to read and not apparently slow, it’s probably fine.\n\r","id":0,"section":"posts","summary":"I can spend a lot of time trying in futility to optimize custom functions and code.\rI’ll take the time to rewrite the same thing in two or more ways and run some basic benchmarks for performance differences.\rMost of the time I’m just exploring the simplest possible way to perform an action and what would be the most generalizable solution that could extend to other problems.\rI ran into an issue where I had to use a quick function to find the total amount of time a subject in a clinical trial was on a specific dose.","tags":["R","benchmark"],"title":"Three Methods of Completion","uri":"https://jmbarbone.github.io/2020/08/three-ways/","year":"2020"}],"tags":[{"title":"benchmark","uri":"https://jmbarbone.github.io/tags/benchmark/"},{"title":"R","uri":"https://jmbarbone.github.io/tags/r/"}]}