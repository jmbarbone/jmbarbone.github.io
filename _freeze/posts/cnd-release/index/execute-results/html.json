{
  "hash": "a1b0937ef7b616fb0ceb105ee238fb90",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"{cnd} release\"\nsubtitle: A new package for conditions\ndate: \"2025-02-23\"\ncategories: [\"R\"]\ndraft: true\n---\n\n\n\n[`{cnd}`](https://jmbarbone.github.io/cnd) is now on **CRAN**, and I'm pretty excited about this one.\n\nIn [`{fuj}`](https://jmbarbone.github.io/fuj), I included [`new_condition()`](https://jmbarbone.github.io/fuj/reference/new_condition.html) which I used throughout [`{fuj}`](https://jmbarbone.github.io/fuj), and [`{mark}`](https://jmbarbone.github.io/mark).\nNow, after a little more experience using custom condition classes, I've taken a step back and redesigned the implementation to really _super charge_ usage.\n\nLoad up [`{cnd}`](https://jmbarbone.github.io/cnd) and let's get started.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(cnd)\n```\n:::\n\n\n\nThere are two big functions here that will get highlighted:\n\n[`condition()`](https://jmbarbone.github.io/cnd/reference/condition.html)  \nand  \n[`cnd()`](https://jmbarbone.github.io/cnd/reference/condition.html)\n\n\n`condition()` creates a new `cnd::condition_generator` object, which is basically a fancy function.\nThese hold additional metadata, which we'll review in a bit, but know simply that we have to create a generator before creating a condition.\n\nIn the simpliest example, we just need to define a class name.\nWe create the generator, and return it.\nIn the `print()`, we can see the class and the _type_ (\"error\") of our condition.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncond_my_new_condition <- condition(\"my_new_condition\", type = \"error\")\ncond_my_new_condition\n#> cnd::condition_generator\n#> my_new_condition/error\n```\n:::\n\n\n\nWhen we call the generator, it returns the new condition.\nA default message is applied.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncond_my_new_condition()\n#> my_new_condition/error\n#> (my_new_condition/cnd::condition/error/condition)\n#> there was an error\n```\n:::\n\n\n\nThat condition can be passed into `stop()`, to singal the condition and print the message.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstop(cond_my_new_condition())\n#> Error in cond_my_new_condition(): <my_new_condition>\n#> there was an error\n```\n:::\n\n\n\nNow, let's look at a more complicated example.\nWe're going to define a new condition generator, and call it within a function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncond_numeric_error <- condition(\n  \"numeric_error\",\n  message = \"parameters must be numeric\",\n  type = \"error\",\n  package = \"example\"\n)\n\ncond_numeric_error\n#> cnd::condition_generator\n#> example:numeric_error/error\n\nsummation <- function(x, y) {\n  if (!is.numeric(x) || !is.numeric(y)) {\n      stop(cond_numeric_error())\n  }\n  x + y\n}\n\nsummation(1, 2)\n#> [1] 3\nsummation(1, \"2\")\n#> Error in summation(): <example:numeric_error>\n#> parameters must be numeric\n```\n:::\n\n\n\nWith a small adjustment, we can also turn this into a \"warning\" instead, and throw some additional information.\nBecause we're using a function, the `print()` for the `cnd::condition_generator` object gains a new **generator** output, which shows information about this function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncond_numeric_warning <- condition(\n  \"numeric_warning\",\n  message = function(x, y) {\n    x <- typeof(x)\n    y <- typeof(y)\n    types <- setdiff(c(x, y), c(\"double\", \"integer\"))\n    c(\n      paste(\"parameters must be numeric, not:\", toString(types)),\n      \"A coercion attempt will be made\"\n    )\n  },\n  type = \"warning\",\n  package = \"example\"\n)\n\ncond_numeric_warning\n#> cnd::condition_generator\n#> example:numeric_warning/warning \n#> \n#> generator\n#>   $ x : <symbol> \n#>   $ y : <symbol>\n\nsummation <- function(x, y) {\n  if (!is.numeric(x) || !is.numeric(y)) {\n    print(sys.call())\n    warning(cond_numeric_warning(x, y))\n    x <- as.numeric(x)\n    y <- as.numeric(y)\n  }\n  x + y\n}\n\nsummation(1, 2)\n#> [1] 3\nsummation(1, \"2\")\n#> summation(1, \"2\")\n#> Warning in summation(): <example:numeric_warning>\n#> parameters must be numeric, not: character\n#> A coercion attempt will be made\n#> [1] 3\nsummation(list(1), \"2\")\n#> summation(list(1), \"2\")\n#> Warning in summation(): <example:numeric_warning>\n#> parameters must be numeric, not: list, character\n#> A coercion attempt will be made\n#> [1] 3\n```\n:::\n\n\n\nYou can assign conditions to `function`, which stores them in the `\"conditions\"` attribute.\nThis also updates the class of the object, which allows us to see which conditions has been assigned to the function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconditions(summation) <- cond_numeric_warning\nsummation\n#> function (x, y) \n#> {\n#>     if (!is.numeric(x) || !is.numeric(y)) {\n#>         print(sys.call())\n#>         warning(cond_numeric_warning(x, y))\n#>         x <- as.numeric(x)\n#>         y <- as.numeric(y)\n#>     }\n#>     x + y\n#> }\n#> <bytecode: 0x567c75219308>\n#> \n#> condition(s)\n#> example:numeric_warning/warning\n```\n:::\n\n\n\nConditions do not need to be exported to be retrieved.\nWhen you see the name, you can use that as a character string within `cond()` to retrieve the object.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncond(\"example:numeric_warning\")\n#> cnd::condition_generator\n#> example:numeric_warning/warning \n#> \n#> generator\n#>   $ x : <symbol> \n#>   $ y : <symbol>\n```\n:::\n\n\n\n::: {callout-tip}\n`{cnd}` will try to use the `{cli}` package under the hood.\nIn places where the condition names are printed, you should be able to _click_ on them, too, which will execute `cond()` and retrieve the condition.\n:::\n\nFor more general searches, use `conditions()` and define some options.\nBelow we will grab all `warning` conditions from `{cnd}`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconditions(\"cnd\", type = \"warning\")\n```\n\n````\n#> [[1]]\n#> cnd::condition_generator\n#> cnd:cnd_document_conditions/warning \n#> \n#> exports\n#>   cnd::cnd_document()\n#> \n#> [[2]]\n#> cnd::condition_generator\n#> cnd:condition_overwrite/warning \n#> \n#> generator\n#>   $ old : <symbol> \n#>   $ new : <symbol> \n#> \n#> exports\n#>   cnd::condition()\n#> \n#> [[3]]\n#> cnd::condition_generator\n#> cnd:conditions_dots/warning \n#> \n#> help\n#> The `...` parameter in [conditions()] is meant for convenience.  Only a single argument is allowed.  Other parameters must be named  explicitly.  For example:  ```r # Instead of this conditions(\"class\", \"package\") # \"package\" is ignored with a warning  # Do this conditions(class = \"class\", package = \"package\") ``` \n#> \n#> exports\n#>   cnd::conditions()\n#> \n#> [[4]]\n#> cnd::condition_generator\n#> cnd:no_package_exports/warning \n#> \n#> help\n#> The `exports` parameter requires a `package` \n#> \n#> exports\n#>   cnd::condition()\n````\n:::\n\n\n\nOne of the most exciting features about `{cnd}` is the package documentation.\nIt's now very easy to define new conditions, which signal warnings or errors, and provide users with more immediate knowledge.\n\nWith our `summation()` function, we can generate `roxygen` friendly documentation \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncat(cnd_section(summation))\n#> \n#> Conditions are generated through the [`{cnd}`][cnd::cnd-package] package.\n#> The following conditions are associated with this function:\n#> \n#> \\describe{\n#>   \n#>   \\item{[`example:numeric_warning/warning`][example-cnd-conditions]}{\n#>     \n#>   }\n#> \n#> }\n#> \n#> For more conditions, see: [example-cnd-conditions]\n```\n:::\n\n\n\nFor more information, see https://jmbarbone.github.io/cnd and https://github.com/jmbarbone/cnd.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}