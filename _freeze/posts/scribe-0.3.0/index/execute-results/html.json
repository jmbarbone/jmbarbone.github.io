{
  "hash": "653a92d2f9ab55f0ba98654a4508d291",
  "result": {
    "markdown": "---\ntitle: \"`{scribe} 0.3.0` release\"\nsubtitle: \"A package to support `Rscript` files\"\ndate: \"2023-10-21\"\ncategories: [\"R\", \"{scribe}\"]\n---\n\n\nAfter months of using my own `Rscript` utils with `{scribe}` I've failed to notice a now obvious error in my attempts to include type conversions.\nThe original approach was a little too complicated and a too much for what would be needed in most cases.\n\nThis update includes a breaking change for how conversion works in `{scribe}`.\n\nIn the prior minor release, this would be valid:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(scribe)\n```\n:::\n\n\n\n```r\nca <- command_args(string = \"-a 1 -b 0\")\nca$add_argument(\"-a\", convert = integer())\nca$add_argument(\"-b\", convert = character())\nargs <- ca$parse()\nargs$a + args$b\n#> a\n#> [1] 1\n#> \n#> $b\n#> [1] \"0\"\n```\n\nHowever, there were issues with trying to use a default value and trying to use a conversion value.\nInstead, a new exported `scribe_convert()` is included to handle default and custom conversions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscribe_convert()\n#> function (x, to = default_convert) \n#> {\n#>     if (!is.character(x) || is.null(to)) {\n#>         return(x)\n#>     }\n#>     if (is.factor(to)) {\n#>         return(factor(x, levels = levels(to), ordered = is.ordered(to)))\n#>     }\n#>     if (is.function(to)) {\n#>         to <- match.fun(to)\n#>         return(to(x))\n#>     }\n#>     mode(x) <- mode(to)\n#>     storage.mode(x) <- storage.mode(to)\n#>     attributes(x) <- attributes(to)\n#>     class(x) <- class(to)\n#>     x\n#> }\n#> <bytecode: 0x5579b81e89a0>\n#> <environment: namespace:scribe>\n```\n:::\n\n\nThis defaults to returning `value_convert()` (which may be unexported in the future) and provides other options for `\"none\"`, and `\"evaluate\"`.\nThe latter provides useful alternatives for including new values:\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- new_arg(convert = scribe_convert(\"evaluate\"))\na$convert(\"1:2\")\n#> [1] 1 2\na$convert(\"data.frame(a = 1, b = 2)\")\n#>   a b\n#> 1 1 2\n```\n:::\n\n\nYou still have the option for custom conversions, and use the methods of `scribe_value()` by just passing the method as a string.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nca <- command_args(c(\"-a\", 0, \"-b\", \"2023-10-21\", \"-c\", \"list(2, 3)\", \"-d\", 4.4, \"-e\", 5))\nca$add_argument(\"-a\", convert = \"none\")\nca$add_argument(\"-b\", convert = \"default\")\nca$add_argument(\"-c\", convert = \"evaluate\")\nca$add_argument(\"-d\", convert = as.integer)\nca$add_argument(\"-e\", convert = \\(x) rep(\"value\", x))\nstr(ca$parse())\n#> List of 5\n#>  $ a: chr \"0\"\n#>  $ b: POSIXct[1:1], format: \"2023-10-21\"\n#>  $ c:List of 2\n#>   ..$ : num 2\n#>   ..$ : num 3\n#>  $ d: int 4\n#>  $ e: chr [1:5] \"value\" \"value\" \"value\" \"value\" ...\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}