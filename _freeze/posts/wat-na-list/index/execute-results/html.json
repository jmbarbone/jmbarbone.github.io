{
  "hash": "e77ba9152e27cecea0defb6e06ebe1b0",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"wat? Character NAs\"\nsubtitle: \"But it is documented\"\ndate: now\ncategories: [\"R\", \"{fuj}\"]\ndraft: true\n---\n\n\n::: {.callout-note}\nThis interesting behavior was related to [`{fuj} v0.2.0 lst()`](https://github.com/jmbarbone/fuj/blob/v0.2.0/R/list.R) behavior.\nAn issue was created to track the fix: [jmbarbone/fuj#60](https://github.com/jmbarbone/fuj/issues/60).\n:::\n\n<iframe src=\"https://fosstodon.org/@barbone/112401680792851241/embed\" class=\"mastodon-embed\" style=\"max-width: 100%; border: 0\" width=\"800\" allowfullscreen=\"allowfullscreen\"></iframe><script src=\"https://fosstodon.org/embed.js\" async=\"async\"></script>\n\nShort answer: Yes.\nFeel free to read through the journey of discovery.\n\nThe original post showed the behavior with [`substitute()`](https://rdrr.io/r/base/substitute.html), which made this feel a little more confusing that it really is.\n\nWhen trying to compare two values, **R** makes an attempt to find a common data type.\nThis shouldn't be new:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# double and integer\n0.0 == 0L\n#> [1] TRUE\n\n# double and logical\n0 == FALSE\n#> [1] TRUE\n\n# double and character\n0 == \"0\"\n#> [1] TRUE\n\n# date and character\nas.Date(\"2024-05-08\") == \"2024-05-08\"\n#> [1] TRUE\n```\n:::\n\n\nIn the above examples, all the values are coerced to the same type before the comparison is made.\nThese all resolve in the values being _equal_.\nHowever, there is a special behavior invoked when we compare lists.\n\nHere's the _wat_ simplified:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# NA resolves to NA\nNA == \"\"\n#> [1] NA\nNA_character_ == \"\"\n#> [1] NA\n\n# but not in a list\nlist(NA) == \"\"\n#> [1] FALSE\n\n# unless it's a character\nlist(NA_character_) == \"\"\n#> [1] NA\n```\n:::\n\n\nLet's rewrite this as direct character conversions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.character(NA)\n#> [1] NA\nas.character(NA_character_)\n#> [1] NA\nas.character(list(NA))\n#> [1] \"NA\"\nas.character(list(NA_character_))\n#> [1] NA\n```\n:::\n\n\nThere it is: `list(NA)` turns into `\"NA\"`.\n_wat_?\nWell, these two help files provide the relevant information on what is happening here:\n\n> Language objects such as symbols and calls are deparsed to character strings before comparison.  \n[`?base::Comparison`, Details](https://rdrr.io/r/base/Comparison.html)\n\n> For lists and pairlists (including language objects such as calls) it deparses the elements individually, except that it extracts the first element of length-one character vectors.  \n[`?base::character`, Value](https://rdrr.io/r/base/character.html)\n\nThe extraction of length 1 character vectors is the described behavior that I was missing.\nWhen calling [`deparse()`](https://rdrr.io/r/base/deparse.html) on a non-list vector, we get a different result for `NA` and `NA_character_`:\nSo, here's what happens:\n\n1. **R** detects that one comparison is a list\n2. **R** converts the list vector to a character vector\n3. For each element in the list, **R** converts checks if it is a single length character vector or not\n4. If it is a single length character vector, **R** simply returns the (first element of the) value \n5. If it is not a single length character vector, **R** _deparses_ the value\n\nWe can replicate this with a custom function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_convert <- function(x) {\n  do <- function(i) {\n    if (is.character(i) && length(i) == 1L) {\n      # extracts the first element of length-one character vectors\n      return(i[1L])\n    }\n    \n    # deparses elements individually\n    deparse1(i, control = NULL)\n  }\n  \n  # determine routine for each element\n  vapply(x, do, \"\", USE.NAMES = FALSE)\n}\n\nx <- list(1:3, NA, NA_real_, NA_character_)\nwaldo::compare(as.character(x), sapply(x, deparse, control = NULL))\n#> `old`: \"1:3\" \"NA\" \"NA\" NA  \n#> `new`: \"1:3\" \"NA\" \"NA\" \"NA\"\nwaldo::compare(as.character(x), my_convert(x))\n#> âœ” No differences\n```\n:::\n\n\n::: {.callout-tip}\nThere is a default `control` of `\"keepNA\"`, which retains additional information about our `NA` values.\nThe `list` to `character` conversion doesn't seem to use this as all the values are resolved to `\"NA\"` rather than `\"NA_character_\"`, or the like.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(x, deparse, control = \"keepNA\")\n#> [1] \"1:3\"           \"NA\"            \"NA_real_\"      \"NA_character_\"\n```\n:::\n\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}