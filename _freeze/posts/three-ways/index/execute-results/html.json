{
  "hash": "0995e09768fa639564c4288736e68b86",
  "result": {
    "markdown": "---\ntitle: Solving one task with three equivalent solutions\nsubtitle: \"`for`, `do.call`, `vapply`\"\ndate: \"2020-08-05\"\ncategories: [\"R\", \"benchmark\"]\n---\n\n\nI can spend a lot of time trying in futility to optimize custom functions and code.\nI'll take the time to rewrite the same thing in two or more ways and run some basic benchmarks for performance differences.\nMost of the time I'm just exploring the simplest possible way to perform an action and what would be the most generalizable solution that could extend to other problems.\nI ran into an issue where I had to use a quick function to find the total amount of time a subject in a clinical trial was on a specific dose.\nHowever, subjects had doses adjusted through the study for optimization.\nFurther, we also needed to count the dosing based on the lowest dose provided.\n\n> For example, how long was Subject A on a >= 10mg dose?\n\nSo, let's explore three different ways to solve this problem and why all three are valid and just as efficient.\n\n## Set up\n\nLoading our `tidyverse` packages first.\nBecause we will be grouping and summarising data in a data.frame, I really don't feel like going through the trouble of using `base` solutions.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(tidyverse.quiet = TRUE) # Silences messages\nlibrary(tidyverse)\n```\n:::\n\n\nLet's create some random data to represent our subjects, our doses, and an arbitrary time metric.\nWe're also going to make this harder by using the `difftime`.\n\nWe're also going to grab some names using a function from the [`wakefield` package](https://github.com/trinker/wakefield) which you can use to create fake data, appropriately named. [^note]\n\n^note: I'm not too savvy with this package yet but would like to experiment more for building dummy data sets.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubj <- sort(sample(wakefield::name(500), 1e4, TRUE))\ndose <- sample(seq.int(10, 80, 10), 1e4, TRUE)\ntime <- as.difftime(runif(1e4) * 100, units = \"days\")\n\ndf <- tibble(subj, dose, time)\ndf\n#> # A tibble: 10,000 × 3\n#>    subj     dose time          \n#>    <chr>   <dbl> <drtn>        \n#>  1 Aadhya     10 81.430584 days\n#>  2 Aadhya     10 80.324186 days\n#>  3 Aadhya     40 64.917350 days\n#>  4 Aadhya     80 17.631323 days\n#>  5 Aadhya     40  8.970711 days\n#>  6 Aadhya     20 96.518079 days\n#>  7 Aadhya     60 61.493537 days\n#>  8 Aadhya     20 29.073014 days\n#>  9 Aadhya     80  6.221622 days\n#> 10 Aaditri    50 54.387006 days\n#> # … with 9,990 more rows\n```\n:::\n\n\nFinding the total sum of time at each dose is easy:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% \n  group_by(subj, dose) %>% \n  summarise(time = sum(time), .groups = \"drop\") %>% \n  pivot_wider(\n    names_from = \"dose\",\n    names_sort = TRUE,\n    values_from = \"time\"\n    )\n#> # A tibble: 500 × 9\n#>    subj    `10`            `20`           `30`     `40`  `50`  `60`  `70`  `80` \n#>    <chr>   <drtn>          <drtn>         <drtn>   <drt> <drt> <drt> <drt> <drt>\n#>  1 Aadhya  161.754770 days 125.59109 days        …  73.…     …  61.…     …  23.…\n#>  2 Aaditri  30.671230 days 172.20370 days        … 224.… 131.… 193.…  67.…  93.…\n#>  3 Aaleeya 174.678539 days 115.27412 days 159.963… 198.… 184.…  77.… 214.… 292.…\n#>  4 Aaleyah 183.860531 days  88.26322 days        …   9.… 261.… 259.… 214.… 100.…\n#>  5 Aamia    70.429895 days 149.78110 days 122.847…  40.…  32.…  74.… 116.… 161.…\n#>  6 Aarish  232.188970 days 234.42468 days  70.517…     …   7.… 111.… 153.… 118.…\n#>  7 Abdulah   8.890604 days  37.66665 days 130.246…     …     … 215.… 159.… 162.…\n#>  8 Abhinav 221.372920 days 108.87628 days 114.363… 280.… 136.… 100.…  97.…  95.…\n#>  9 Abhiram  73.235939 days 182.81309 days 295.836… 107.…  96.… 137.… 123.…  68.…\n#> 10 Abyade  107.638230 days 596.18206 days 168.711… 146.…  61.…  34.… 281.… 149.…\n#> # … with 490 more rows\n```\n:::\n\n\nOh, it looks like we have some missing values (see the first line where we are missing doses of `30`, `50`, and `70` for `Aadhya`.).\n`tidyr::pivot_wider()` allows us to fill in the missing values but like many `tidyverse` functions, we'll have to be explicit with the type so as to not case any accidental issues.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndifftime0 <- as.difftime(0, units = \"days\")\n\nres <- df %>% \n  group_by(subj, dose) %>% \n  summarise(time = sum(time), .groups = \"drop\") %>% \n  pivot_wider(\n    names_from = \"dose\",\n    names_sort = TRUE,\n    values_from = \"time\",\n    values_fill = difftime0\n  )\nres\n#> # A tibble: 500 × 9\n#>    subj    `10`            `20`           `30`     `40`  `50`  `60`  `70`  `80` \n#>    <chr>   <drtn>          <drtn>         <drtn>   <drt> <drt> <drt> <drt> <drt>\n#>  1 Aadhya  161.754770 days 125.59109 days   0.000…  73.…   0.…  61.…   0.…  23.…\n#>  2 Aaditri  30.671230 days 172.20370 days   0.000… 224.… 131.… 193.…  67.…  93.…\n#>  3 Aaleeya 174.678539 days 115.27412 days 159.963… 198.… 184.…  77.… 214.… 292.…\n#>  4 Aaleyah 183.860531 days  88.26322 days   0.000…   9.… 261.… 259.… 214.… 100.…\n#>  5 Aamia    70.429895 days 149.78110 days 122.847…  40.…  32.…  74.… 116.… 161.…\n#>  6 Aarish  232.188970 days 234.42468 days  70.517…   0.…   7.… 111.… 153.… 118.…\n#>  7 Abdulah   8.890604 days  37.66665 days 130.246…   0.…   0.… 215.… 159.… 162.…\n#>  8 Abhinav 221.372920 days 108.87628 days 114.363… 280.… 136.… 100.…  97.…  95.…\n#>  9 Abhiram  73.235939 days 182.81309 days 295.836… 107.…  96.… 137.… 123.…  68.…\n#> 10 Abyade  107.638230 days 596.18206 days 168.711… 146.…  61.…  34.… 281.… 149.…\n#> # … with 490 more rows\n```\n:::\n\n\nThis is much more troublesome as we have to create single length `difftime` vector.\n\nNow, we need to find the total length of time a subject was at each dose or greater..\nThis I wasn't able to do with any built in functions (although I could have missed it).\nI'm not claiming this is the best function or anything, it's not, but I have 3 different solutions and thought it was enough to spend my evening writing a blog post.\n\n### Solution 1: The for Loop\n\nNever use a for loop, except if you have to.\nWe'll start with\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfoo1 <- function(x, y) {\n  out <- y\n  \n  for (i in seq_along(y)) {\n    out[i] <- sum(y[x >= x[i]])\n  }\n  \n  out\n}\n```\n:::\n\n\n### Solution 2: Combining lapply\n\nWhen having to play with dates before, I found that the way I could retain the date values and still use a function from the `apply` family was to stick with the `lapply()` and then use the `do.call()` function to apply the `c`ombine function over my list.\n`lapply()` retains the original classes and using the `do.call(c, ...)` method will turn my list into a vector without removing the structure of the output\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfoo2 <- function(x, y) {\n  out <- lapply(x, function(xx) sum(y[x >= xx]))\n  do.call(c, out)\n}\n```\n:::\n\n\nLet's see how this plays out.\nIf we use other methods, we lose the difftime class, which is noticeable as we don't get our message of `Time differences in days` before our results.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- lapply(dose, function(xx) sum(time[dose >= xx])) %>% unlist() %>% head()\nprint_with_class_type(x)\n#> class  numeric\n#> typeof double\n#> [1] 501497.92 501497.92 312102.52  61765.11 312102.52 437797.16\n\nx <- sapply(dose, function(xx) sum(time[dose >= xx])) %>% head()\nprint_with_class_type(x)\n#> class  numeric\n#> typeof double\n#> [1] 501497.92 501497.92 312102.52  61765.11 312102.52 437797.16\n\nx <- foo2(dose, time) %>% head()\nprint_with_class_type(x)\n#> class  difftime\n#> typeof double\n#> Time differences in days[1] 501497.92 501497.92 312102.52  61765.11 312102.52 437797.16\n```\n:::\n\n\n\n### Solution 3: vapply with subset assigning\n\nHere's another neat little trick that with a good use case.\nWe're going to subset our `out` object (again, a copy of the `y` intput) and assign over it the result of our `vapply`.\nWe're also going to _cheat_ and use the first position of `y` as our `FUN.VALUE`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfoo3 <- function(x, y) {\n  out <- y\n  out[] <- vapply(x, function(xx) sum(y[x >= xx]), y[1], USE.NAMES = FALSE)\n  out\n}\n```\n:::\n\n\nLet's take look just like before.\n`vapply()` will try to simplify the `FUN.VALUE` but as long as we use a single vector from the original input we can safely assign it back into our mock subset without worrying about losing our classes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- vapply(dose, function(xx) sum(time[dose >= xx]), time[1]) %>% head()\nprint_with_class_type(x)\n#> class  numeric\n#> typeof double\n#> [1] 501497.92 501497.92 312102.52  61765.11 312102.52 437797.16\n\nx < -foo3(dose, time) %>% head()\n#> [1] FALSE FALSE FALSE FALSE FALSE FALSE\nprint_with_class_type(x)\n#> class  numeric\n#> typeof double\n#> [1] 501497.92 501497.92 312102.52  61765.11 312102.52 437797.16\n```\n:::\n\n\n## Benchmarks\n\nNow, all three of these solutions produce the same results and are fairly equivalent in human legibility.\nThis means, for me at least, that the function which runs the fastest would be the result I keep.\nWe'll employ the `bench` package and eponymous name for our consideration.\n\nOf course, for this we'll be running on the vectors first.\nWe'll also make certain that all of our outputs are the same with `check = TRUE` (default) to make sure we didn't miss anything either.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(\n  `1` = foo1(dose, time),\n  `2` = foo2(dose, time),\n  `3` = foo3(dose, time),\n  check = TRUE\n)\n#> Warning: Some expressions had a GC in every iteration; so filtering is disabled.\n#> # A tibble: 3 × 6\n#>   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 1             3.41s    3.41s     0.293    2.96GB     22.3\n#> 2 2             2.73s    2.73s     0.366    2.22GB     14.3\n#> 3 3             2.67s    2.67s     0.375    2.21GB     13.1\n```\n:::\n\n\nAnd, well, they all run about the same.\nThat kind of just leaves us with the sinking feeling that all of this was futile and that `for` loops really aren't that bad.\nIn fact, the `for` loop solution may be the easiest to read and doesn't use any tricks that someone reviewing your code may not understand at first.\n\nWe know we have some missing values in our data, so we're going to use the the `tidyr::complete()` function to help with that.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres\n#> # A tibble: 500 × 9\n#>    subj    `10`            `20`           `30`     `40`  `50`  `60`  `70`  `80` \n#>    <chr>   <drtn>          <drtn>         <drtn>   <drt> <drt> <drt> <drt> <drt>\n#>  1 Aadhya  161.754770 days 125.59109 days   0.000…  73.…   0.…  61.…   0.…  23.…\n#>  2 Aaditri  30.671230 days 172.20370 days   0.000… 224.… 131.… 193.…  67.…  93.…\n#>  3 Aaleeya 174.678539 days 115.27412 days 159.963… 198.… 184.…  77.… 214.… 292.…\n#>  4 Aaleyah 183.860531 days  88.26322 days   0.000…   9.… 261.… 259.… 214.… 100.…\n#>  5 Aamia    70.429895 days 149.78110 days 122.847…  40.…  32.…  74.… 116.… 161.…\n#>  6 Aarish  232.188970 days 234.42468 days  70.517…   0.…   7.… 111.… 153.… 118.…\n#>  7 Abdulah   8.890604 days  37.66665 days 130.246…   0.…   0.… 215.… 159.… 162.…\n#>  8 Abhinav 221.372920 days 108.87628 days 114.363… 280.… 136.… 100.…  97.…  95.…\n#>  9 Abhiram  73.235939 days 182.81309 days 295.836… 107.…  96.… 137.… 123.…  68.…\n#> 10 Abyade  107.638230 days 596.18206 days 168.711… 146.…  61.…  34.… 281.… 149.…\n#> # … with 490 more rows\n\ndf %>% \n  complete(subj, dose, fill = list(time = difftime0)) %>% \n  group_by(subj, dose) %>% \n  summarise(time = sum(time), .groups = \"drop_last\") %>%\n  mutate(time = foo1(dose, time)) %>% \n  pivot_wider(\n    names_from = \"dose\",\n    names_sort = TRUE,\n    values_from = \"time\"\n  )\n#> # A tibble: 500 × 9\n#> # Groups:   subj [500]\n#>    subj    `10`           `20`           `30`      `40`  `50`  `60`  `70`  `80` \n#>    <chr>   <drtn>         <drtn>         <drtn>    <drt> <drt> <drt> <drt> <drt>\n#>  1 Aadhya   446.5804 days  284.8256 days  159.234… 159.…  85.…  85.…  23.…  23.…\n#>  2 Aaditri  913.9830 days  883.3118 days  711.108… 711.… 486.… 354.… 161.…  93.…\n#>  3 Aaleeya 1417.4559 days 1242.7773 days 1127.503… 967.… 769.… 584.… 507.… 292.…\n#>  4 Aaleyah 1117.0842 days  933.2237 days  844.960… 844.… 835.… 573.… 314.… 100.…\n#>  5 Aamia    769.4857 days  699.0558 days  549.274… 426.… 385.… 352.… 278.… 161.…\n#>  6 Aarish   927.1830 days  694.9940 days  460.569… 390.… 390.… 382.… 271.… 118.…\n#>  7 Abdulah  714.1323 days  705.2417 days  667.575… 537.… 537.… 537.… 321.… 162.…\n#>  8 Abhinav 1154.8195 days  933.4466 days  824.570… 710.… 429.… 292.… 192.…  95.…\n#>  9 Abhiram 1086.0283 days 1012.7924 days  829.979… 534.… 426.… 329.… 192.…  68.…\n#> 10 Abyade  1545.7654 days 1438.1272 days  841.945… 673.… 526.… 465.… 431.… 149.…\n#> # … with 490 more rows\n```\n:::\n\n\nAnd there you go.\nThree solutions, all the same.\n\nSometimes it's useful to try to optimize code.\nOther times it's just results in a blog post.\n\nAs long as your code is easy to read and not apparently slow, it's probably fine.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}